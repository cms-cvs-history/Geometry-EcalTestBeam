#ifndef GEOMETRY_ECALGEOMETRYLOADER_ICC
#define GEOMETRY_ECALGEOMETRYLOADER_ICC 1

#include "CondFormats/Alignment/interface/AlignTransform.h"

#include "CaloGeometryLoader.h"

#include "Geometry/CaloGeometry/interface/CaloCellGeometry.h"

#include "Geometry/CaloGeometry/interface/CaloGenericDetId.h"

#include "DetectorDescription/Core/interface/DDCompactView.h"
#include "DetectorDescription/Core/interface/DDCurrentNamespace.h"
#include "DetectorDescription/Core/interface/DDLogicalPart.h"
#include "DetectorDescription/Core/interface/DDSolid.h"
#include "DetectorDescription/Core/interface/DDMaterial.h"
#include "DetectorDescription/Core/interface/DDTransform.h"
#include "DetectorDescription/Core/interface/DDCompactView.h"
#include "DetectorDescription/Core/interface/DDExpandedView.h"
#include "DetectorDescription/Core/interface/DDNodes.h"
#include "DetectorDescription/Core/interface/DDSpecifics.h"
#include "DetectorDescription/Core/interface/DDName.h"
#include "DetectorDescription/Core/interface/DDScope.h"
#include "DetectorDescription/Core/interface/DDFilter.h"
#include "DetectorDescription/Core/interface/DDQuery.h"
#include "DetectorDescription/Core/interface/DDFilteredView.h"
#include "DetectorDescription/ExprAlgo/interface/ExprEvalSingleton.h"

#include "CLHEP/Units/GlobalSystemOfUnits.h"

#include <vector>

using namespace std;

template <class T>
const double 
CaloGeometryLoader<T>::k_ScaleFromDDDtoGeant ( 0.1 ) ;

template <class T>
CaloGeometryLoader<T>::CaloGeometryLoader() 
{
   m_filter.setCriteria( DDValue( "Volume",
				  "EESCEnv1",
				  0                  ),
			 DDSpecificsFilter::equals,
			 DDSpecificsFilter::AND,
			 true,
			 true                       ) ;
}

template <class T>
typename CaloGeometryLoader<T>::PtrType
CaloGeometryLoader<T>::load( const DDCompactView*  cpv        ,
			     const Alignments*     alignments ,
			     const Alignments*     globals       ) 
{
   PtrType geom ( new T ) ;

   makeGeometry( cpv,
		 dynamic_cast<T*>( geom.get() ),
		 alignments,
		 globals ) ;

   return geom ;
}

template <class T>
void 
CaloGeometryLoader<T>::makeGeometry( const DDCompactView*  cpv        ,
				     T*                    geom       ,
				     const Alignments*     alignments ,
				     const Alignments*     globals      )
{
   std::cout<<"********************************* here in makeGeometry ********"<<std::endl ;

   DDFilteredView fv0 ( *cpv ) ;
   fv0.addFilter( m_filter ) ;

   fillNamedParams( fv0, geom ) ;

   geom->allocateCorners( T::k_NumberOfCellsForCorners ) ;
   geom->allocatePar( T::k_NumberOfParametersPerShape*T::k_NumberOfShapes,
		      T::k_NumberOfParametersPerShape ) ;

   DDFilteredView fv( *cpv ) ;
   fv.addFilter( m_filter ) ;
 
   unsigned int counter ( 0 ) ;
   for( bool doSubDets = fv.firstChild(); doSubDets ; doSubDets = fv.nextSibling() )
   {
      ++counter ;
      const DDSolid& solid ( fv.logicalPart().solid() ) ;
      
      const ParmVec& parameters ( solid.parameters() ) ;

      DD3Vector x, y, z;
      fv.rotation().GetComponents( x, y, z ) ;
      const CLHEP::HepRep3x3 temp( x.X(), y.X(), z.X(),
				   x.Y(), y.Y(), z.Y(),
			           x.Z(), y.Z(), z.Z() );
      const CLHEP::HepRotation hr ( temp );
      const CLHEP::Hep3Vector h3v ( fv.translation().X(),
		 		    fv.translation().Y(),
				    fv.translation().Z()  ) ;
      const HepGeom::Transform3D ht3d ( hr,          // only scale translation
	 	 		        k_ScaleFromDDDtoGeant*h3v ) ;    

      const unsigned int id ( getDetIdForDDDNode( fv ) ) ;

/*      const unsigned int which ( geom->alignmentTransformIndexLocal( id ) ) ;

      assert( 0 == alignments ||
	      which < alignments->m_align.size() ) ;

      const AlignTransform* at ( 0 == alignments ? 0 :
				 &alignments->m_align[ which ] ) ;

      assert( 0 == at || ( geom->alignmentTransformIndexLocal( DetId( at->rawId() ) ) == which ) ) ;

      const unsigned int gIndex ( 0 ) ; //geom->alignmentTransformIndexGlobal( id ) ) ;

      const AlignTransform* globalT ( 0 == globals ? 0 :
				      ( globals->m_align.size() > gIndex ? 
					&globals->m_align[ gIndex ] : 0 ) ) ;

      const HepGeom::Transform3D atr ( 0 == at ? ht3d :
				 ( 0 == globalT ? at->transform()*ht3d :
				   globalT->transform()*at->transform()*ht3d ) ) ;
*/
      myFillGeom( geom, parameters, ht3d, id ) ;
   }

//   assert( counter <= T::k_NumberOfCellsForCorners ) ;

//   geom->initializeParms() ;
}


template <class T>
void
CaloGeometryLoader<T>::myFillGeom( T*                    geom ,
				   const ParmVec&          vv ,
				   const HepGeom::Transform3D&   tr ,
				   const unsigned int      id     )
{
   std::vector<double> pv ;
   pv.reserve( vv.size() ) ;
   for( unsigned int i ( 0 ) ; i != vv.size() ; ++i )
   {
      const double factor ( 1==i || 2==i || 6==i || 10==i ? 1 : k_ScaleFromDDDtoGeant ) ;
      pv.push_back( factor*vv[i] ) ;
   }

   CaloCellGeometry::CornersVec corners ( geom->cornersMgr() ) ;
   corners.resize() ;

   TruncatedPyramid::createCorners( pv, tr, corners ) ;

   if( 160 == id ||
       164 == id ||
       134 == id ||
       130 == id    )
   {
      std::cout<<"\n *************** id = "<<id
	       <<"\n "<<corners[0]
	       <<"\n "<<corners[1]
	       <<"\n "<<corners[2]
	       <<"\n "<<corners[3]
	       <<"\n "<<corners[4]
	       <<"\n "<<corners[5]
	       <<"\n "<<corners[6]
	       <<"\n "<<corners[7]
	       <<std::endl ;
   }

/*
   const double* parmPtr ( CaloCellGeometry::getParmPtr( pv, 
							 geom->parMgr(), 
							 geom->parVecVec() ) ) ;

   TruncatedPyramid* cell ( new TruncatedPyramid( corners , parmPtr ) ) ;

   geom->addCell( id, cell );
*/
}

template <class T>
unsigned int 
CaloGeometryLoader<T>::getDetIdForDDDNode( const DDFilteredView& fv )
{
  // perform some consistency checks
  // get the parents and grandparents of this node

  const DDGeoHistory& parents ( fv.geoHistory() ) ;
  const DDGeoHistory::size_type psize ( parents.size() ) ;

  EcalBaseNumber baseNumber ;
  baseNumber.setSize( psize ) ;

  for( unsigned int i=1 ; i<=psize ; ++i )
  {
     baseNumber.addLevel( parents[psize-i].logicalPart().name().name(),
			  parents[psize-i].copyno() ) ;
  }

  return baseNumber.getCopyNumber(0) ;


//  return m_scheme.getUnitID( baseNumber );  
}


#endif
